## 문제

눈송이들이 많은 동네인 숙명여대 앞마당에서 눈사람 만들기 대회를 연다. 앞마당의 길이는
$N$이고 위치
$1$부터 위치
$N$ 까지만 눈이 쌓여있다. 위치
$i$에 눈이
$a_i$만큼 쌓여있다. 대회 규칙은 해당 앞마당에서
$M$초 동안 눈덩이를 굴려 눈사람을 만드는 것이다. 눈덩이의 시작 크기는
$1$이다. 눈덩이의 시작 위치는
$0$이다.

가장 큰 눈사람을 만들고 싶던 수수는 눈덩이를 굴리는 법을 연구했다. 눈덩이를 굴리는 방법에는 두 가지가 있다. 눈덩이를 굴리거나 던질 때 1초가 소모된다.

1. 눈덩이를 현재 위치 +1칸으로 굴린다. 현재 칸의 위치를
   $i$라고 하면 눈덩이의 크기는
   $a_{i+1}$ 만큼 늘어난다.

2. 눈덩이를 현재 위치 +2칸으로 던진다. 눈덩이가 착지하며 충격을 받아 눈덩이의 크기는 원래의 크기의 반으로 줄어들고 현재 칸의 위치를
   $i$라고 하면 눈덩이의 크기는
   $a_{i+2}$ 만큼 늘어난다. 이 때 소수점은 절사한다. 눈덩이를 던져 크기가
   $0$이 되어도 눈덩이는 사라지지 않는다.

눈덩이가 앞마당의 끝에 도달한 경우 남은 시간과 관계없이 눈덩이 굴리기는 끝이 난다. 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 구하는 프로그램을 작성해보자.

## 입력

첫째 줄에 공백을 기준으로 앞마당의 길이
$N$ (
$1 \leq N \leq 100$), 대회의 시간
$M$ (
$1 \leq M \leq 10$)이 주어진다.

둘째 줄에 길이가
$N$인 수열
$a$가 주어진다. (
$1 \leq a_i \leq 1\,000\,000$)

## 출력

첫째 줄에 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 출력한다.

## 풀이

```
let fs = require("fs");
let input = fs.readFileSync("index.txt").toString().trim().split('\n');

//앞마당의 길이, 대회의 시간
let [n,m] = input[0].split(' ').map(Number);

//첫 시작 위치가 0이기 때문에 추가
let arr = [0, ...input[1].split(' ').map(Number)];

let answer = 0;

function dfs(index, time, size){
  //시간을 초과하면 종료
  if(time > m) return;

  //초과하기 전에는 계속 눈덩이 사이즈 비교
  if(time <= m){
    answer = Math.max(answer, size);
  }

  //눈덩이 굴리기
  //if문으로 앞마당 길이 내에서 돌아갈 수 있도록
  if(index <= n-1) dfs(index + 1, time + 1, size + arr[index+1]);

  //눈덩이 던지기
  //if문으로 앞마당 길이 내에서 돌아갈 수 있도록
  if(index <= n-2) dfs(index + 2, time + 1, parseInt(size/2) + arr[index+2])
}

dfs(0,0,1);
console.log(answer);
```
